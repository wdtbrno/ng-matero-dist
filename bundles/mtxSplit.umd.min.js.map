{"version":3,"sources":["../../../projects/extensions/split-pane/utils.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/extensions/split-pane/split.component.ts","../../../projects/extensions/split-pane/split-pane.directive.ts","../../../projects/extensions/split-pane/split.module.ts"],"names":["getPointFromEvent","event","undefined","changedTouches","length","x","clientX","y","clientY","getElementPixelSize","elRef","direction","rect","nativeElement","getBoundingClientRect","width","height","getInputBoolean","v","getInputPositiveNumber","defaultValue","Number","isNaN","isUserSizesValid","unit","sizes","total","reduce","_total","s","every","filter","getAreaMinSize","a","size","component","lockSize","minSize","getAreaMaxSize","maxSize","getGutterSideAbsorptionCapacity","sideAreas","pixels","allAreasSizePixel","acc","area","res","areaSnapshot","pixelAbsorb","percentAfterAbsorption","sizePercentAtStart","pixelRemain","sizePixelAtStart","tempPercentSize","maxSizePixel","minSizePixel","getAreaAbsorptionCapacityPercent","containerSizePixel","tempPixelSize","getAreaAbsorptionCapacityPixel","getAreaAbsorptionCapacity","remain","list","push","updateAreaSize","item","Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","value","error","__spread","arguments","concat","MtxSplitComponent","ngZone","cdRef","renderer","this","_direction","_unit","_gutterSize","_gutterStep","_restrictMove","_useTransition","_disabled","_dir","_gutterDblClickDuration","dragStart","EventEmitter","dragEnd","gutterClick","gutterDblClick","dragProgressSubject","Subject","dragProgress$","asObservable","isDragging","dragListeners","snapshot","startPoint","endPoint","displayedAreas","hidedAreas","_clickTimeout","defineProperty","prototype","addClass","removeClass","build","setAttribute","_this","Observable","subscriber","transitionEndSubscriber","pipe","debounceTime","ngAfterViewInit","runOutsideAngular","setTimeout","getNbGutters","addArea","newArea","order","visible","removeArea","some","find","splice","indexOf","updateArea","resetOrders","resetSizes","showArea","areas","_a","apply","hideArea","comp","forEach","_area","getVisibleAreaSizes","map","setVisibleAreaSizes","formatedSizes","_size","stopDragging","sort","b","setStyleOrder","useUserSizes_1","defaultSize_1","wildcardSizeAreas","alreadyGotOne_1","refreshStyleSizes","markForCheck","setStyleFlex","sumGutterSize_1","gutterSize","clickGutter","gutterNum","tempPoint","window","clearTimeout","notify","gutterDblClickDuration","startDragging","gutterOrder","preventDefault","stopPropagation","disabled","lastSteppedOffset","allInvolvedAreasSizePercent","areasBeforeGutter","areasAfterGutter","restrictMove","unshift","t","listen","bind","dragEvent","lockEvents","gutterEls","toArray","offset","dir","steppedOffset","Math","round","gutterStep","areasBefore","areasAfter","abs","all","areaToReset_1","unlockEvents","fct","pop","type","emit","run","ngOnDestroy","Component","args","selector","exportAs","host","class","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","template","NgZone","ElementRef","ChangeDetectorRef","Renderer2","Input","Output","ViewChildren","MtxSplitPaneDirective","split","_order","_minSize","_maxSize","_lockSize","_visible","lockListeners","ngOnInit","transitionListener","propertyName","setStyle","grow","shrink","basis","isMin","isMax","Directive","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { ElementRef } from '@angular/core';\r\n\r\nimport {\r\n  MtxSplitArea,\r\n  MtxSplitPoint,\r\n  MtxSplitAreaSnapshot,\r\n  MtxSplitSideAbsorptionCapacity,\r\n  MtxSplitAreaAbsorptionCapacity,\r\n} from './interface';\r\n\r\nexport function getPointFromEvent(event: MouseEvent | TouchEvent): MtxSplitPoint | null {\r\n  // TouchEvent\r\n  if (\r\n    (event as TouchEvent).changedTouches !== undefined &&\r\n    (event as TouchEvent).changedTouches.length > 0\r\n  ) {\r\n    return {\r\n      x: (event as TouchEvent).changedTouches[0].clientX,\r\n      y: (event as TouchEvent).changedTouches[0].clientY,\r\n    };\r\n  }\r\n  // MouseEvent\r\n  // tslint:disable-next-line: one-line\r\n  else if (\r\n    (event as MouseEvent).clientX !== undefined &&\r\n    (event as MouseEvent).clientY !== undefined\r\n  ) {\r\n    return {\r\n      x: (event as MouseEvent).clientX,\r\n      y: (event as MouseEvent).clientY,\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function getElementPixelSize(\r\n  elRef: ElementRef,\r\n  direction: 'horizontal' | 'vertical'\r\n): number {\r\n  const rect = (elRef.nativeElement as HTMLElement).getBoundingClientRect();\r\n\r\n  return direction === 'horizontal' ? rect.width : rect.height;\r\n}\r\n\r\nexport function getInputBoolean(v: any): boolean {\r\n  return typeof v === 'boolean' ? v : v === 'false' ? false : true;\r\n}\r\n\r\nexport function getInputPositiveNumber<T>(v: any, defaultValue: T): number | T {\r\n  if (v === null || v === undefined) {\r\n    return defaultValue;\r\n  }\r\n\r\n  v = Number(v);\r\n  return !isNaN(v) && v >= 0 ? v : defaultValue;\r\n}\r\n\r\nexport function isUserSizesValid(\r\n  unit: 'percent' | 'pixel',\r\n  sizes: Array<number>\r\n): boolean | number | void {\r\n  // All sizes have to be not null and total should be 100\r\n  if (unit === 'percent') {\r\n    const total = sizes.reduce((_total, s) => (s !== null ? _total + s : _total), 0);\r\n    return sizes.every(s => s !== null) && total && total > 99.9 && total < 100.1;\r\n  }\r\n\r\n  // A size at null is mandatory but only one.\r\n  if (unit === 'pixel') {\r\n    return sizes.filter(s => s === null).length === 1;\r\n  }\r\n}\r\n\r\nexport function getAreaMinSize(a: MtxSplitArea): null | number {\r\n  if (a.size === null) {\r\n    return null;\r\n  }\r\n\r\n  if (a.component.lockSize === true) {\r\n    return a.size;\r\n  }\r\n\r\n  if (a.component.minSize === null) {\r\n    return null;\r\n  }\r\n\r\n  if (a.component.minSize > a.size) {\r\n    return a.size;\r\n  }\r\n\r\n  return a.component.minSize;\r\n}\r\n\r\nexport function getAreaMaxSize(a: MtxSplitArea): null | number {\r\n  if (a.size === null) {\r\n    return null;\r\n  }\r\n\r\n  if (a.component.lockSize === true) {\r\n    return a.size;\r\n  }\r\n\r\n  if (a.component.maxSize === null) {\r\n    return null;\r\n  }\r\n\r\n  if (a.component.maxSize < a.size) {\r\n    return a.size;\r\n  }\r\n\r\n  return a.component.maxSize;\r\n}\r\n\r\nexport function getGutterSideAbsorptionCapacity(\r\n  unit: 'percent' | 'pixel',\r\n  sideAreas: Array<MtxSplitAreaSnapshot>,\r\n  pixels: number,\r\n  allAreasSizePixel: number\r\n): MtxSplitSideAbsorptionCapacity {\r\n  return sideAreas.reduce(\r\n    (acc: any, area) => {\r\n      const res = getAreaAbsorptionCapacity(unit, area, acc.remain, allAreasSizePixel);\r\n      acc.list.push(res);\r\n      acc.remain = res && res.pixelRemain;\r\n      return acc;\r\n    },\r\n    { remain: pixels, list: [] }\r\n  );\r\n}\r\n\r\nfunction getAreaAbsorptionCapacity(\r\n  unit: 'percent' | 'pixel',\r\n  areaSnapshot: MtxSplitAreaSnapshot,\r\n  pixels: number,\r\n  allAreasSizePixel: number\r\n): MtxSplitAreaAbsorptionCapacity | void {\r\n  // No pain no gain\r\n  if (pixels === 0) {\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: 0,\r\n      percentAfterAbsorption: areaSnapshot.sizePercentAtStart,\r\n      pixelRemain: 0,\r\n    };\r\n  }\r\n\r\n  // Area start at zero and need to be reduced, not possible\r\n  if (areaSnapshot.sizePixelAtStart === 0 && pixels < 0) {\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: 0,\r\n      percentAfterAbsorption: 0,\r\n      pixelRemain: pixels,\r\n    };\r\n  }\r\n\r\n  if (unit === 'percent') {\r\n    return getAreaAbsorptionCapacityPercent(areaSnapshot, pixels, allAreasSizePixel);\r\n  }\r\n\r\n  if (unit === 'pixel') {\r\n    return getAreaAbsorptionCapacityPixel(areaSnapshot, pixels, allAreasSizePixel);\r\n  }\r\n}\r\n\r\nfunction getAreaAbsorptionCapacityPercent(\r\n  areaSnapshot: MtxSplitAreaSnapshot,\r\n  pixels: number,\r\n  allAreasSizePixel: number\r\n): MtxSplitAreaAbsorptionCapacity | void {\r\n  const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\r\n  const tempPercentSize = (tempPixelSize / allAreasSizePixel) * 100;\r\n\r\n  // ENLARGE AREA\r\n\r\n  if (pixels > 0) {\r\n    // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\r\n    if (areaSnapshot.area.maxSize !== null && tempPercentSize > areaSnapshot.area.maxSize) {\r\n      // Use area.area.maxSize as newPercentSize and return calculate pixels remaining\r\n      const maxSizePixel = (areaSnapshot.area.maxSize / 100) * allAreasSizePixel;\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: maxSizePixel,\r\n        percentAfterAbsorption: areaSnapshot.area.maxSize,\r\n        pixelRemain: areaSnapshot.sizePixelAtStart + pixels - maxSizePixel,\r\n      };\r\n    }\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: pixels,\r\n      percentAfterAbsorption: tempPercentSize > 100 ? 100 : tempPercentSize,\r\n      pixelRemain: 0,\r\n    };\r\n  }\r\n\r\n  // REDUCE AREA\r\n  // tslint:disable-next-line: one-line\r\n  else if (pixels < 0) {\r\n    // If minSize & newSize smaller than it > absorb to min and return remaining pixels\r\n    if (areaSnapshot.area.minSize !== null && tempPercentSize < areaSnapshot.area.minSize) {\r\n      // Use area.area.minSize as newPercentSize and return calculate pixels remaining\r\n      const minSizePixel = (areaSnapshot.area.minSize / 100) * allAreasSizePixel;\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: minSizePixel,\r\n        percentAfterAbsorption: areaSnapshot.area.minSize,\r\n        pixelRemain: areaSnapshot.sizePixelAtStart + pixels - minSizePixel,\r\n      };\r\n    }\r\n    // If reduced under zero > return remaining pixels\r\n    // tslint:disable-next-line: one-line\r\n    else if (tempPercentSize < 0) {\r\n      // Use 0 as newPercentSize and return calculate pixels remaining\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: -areaSnapshot.sizePixelAtStart,\r\n        percentAfterAbsorption: 0,\r\n        pixelRemain: pixels + areaSnapshot.sizePixelAtStart,\r\n      };\r\n    }\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: pixels,\r\n      percentAfterAbsorption: tempPercentSize,\r\n      pixelRemain: 0,\r\n    };\r\n  }\r\n}\r\n\r\nfunction getAreaAbsorptionCapacityPixel(\r\n  areaSnapshot: MtxSplitAreaSnapshot,\r\n  pixels: number,\r\n  containerSizePixel: number\r\n): MtxSplitAreaAbsorptionCapacity | void {\r\n  const tempPixelSize = areaSnapshot.sizePixelAtStart + pixels;\r\n\r\n  // ENLARGE AREA\r\n\r\n  if (pixels > 0) {\r\n    // If maxSize & newSize bigger than it > absorb to max and return remaining pixels\r\n    if (areaSnapshot.area.maxSize !== null && tempPixelSize > areaSnapshot.area.maxSize) {\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: areaSnapshot.area.maxSize - areaSnapshot.sizePixelAtStart,\r\n        percentAfterAbsorption: -1,\r\n        pixelRemain: tempPixelSize - areaSnapshot.area.maxSize,\r\n      };\r\n    }\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: pixels,\r\n      percentAfterAbsorption: -1,\r\n      pixelRemain: 0,\r\n    };\r\n  }\r\n\r\n  // REDUCE AREA\r\n  // tslint:disable-next-line: one-line\r\n  else if (pixels < 0) {\r\n    // If minSize & newSize smaller than it > absorb to min and return remaining pixels\r\n    if (areaSnapshot.area.minSize !== null && tempPixelSize < areaSnapshot.area.minSize) {\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: areaSnapshot.area.minSize + pixels - tempPixelSize,\r\n        percentAfterAbsorption: -1,\r\n        pixelRemain: tempPixelSize - areaSnapshot.area.minSize,\r\n      };\r\n    }\r\n    // If reduced under zero > return remaining pixels\r\n    // tslint:disable-next-line: one-line\r\n    else if (tempPixelSize < 0) {\r\n      return {\r\n        areaSnapshot,\r\n        pixelAbsorb: -areaSnapshot.sizePixelAtStart,\r\n        percentAfterAbsorption: -1,\r\n        pixelRemain: pixels + areaSnapshot.sizePixelAtStart,\r\n      };\r\n    }\r\n    return {\r\n      areaSnapshot,\r\n      pixelAbsorb: pixels,\r\n      percentAfterAbsorption: -1,\r\n      pixelRemain: 0,\r\n    };\r\n  }\r\n}\r\n\r\nexport function updateAreaSize(unit: 'percent' | 'pixel', item: MtxSplitAreaAbsorptionCapacity) {\r\n  if (unit === 'percent') {\r\n    item.areaSnapshot.area.size = item.percentAfterAbsorption;\r\n  } else if (unit === 'pixel') {\r\n    // Update size except for the wildcard size area\r\n    if (item.areaSnapshot.area.size !== null) {\r\n      item.areaSnapshot.area.size = item.areaSnapshot.sizePixelAtStart + item.pixelAbsorb;\r\n    }\r\n  }\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import {\r\n  Component,\r\n  Input,\r\n  Output,\r\n  ChangeDetectionStrategy,\r\n  ChangeDetectorRef,\r\n  Renderer2,\r\n  AfterViewInit,\r\n  OnDestroy,\r\n  ElementRef,\r\n  NgZone,\r\n  ViewChildren,\r\n  QueryList,\r\n  EventEmitter,\r\n  ViewEncapsulation,\r\n} from '@angular/core';\r\nimport { Observable, Subscriber, Subject } from 'rxjs';\r\nimport { debounceTime } from 'rxjs/operators';\r\n\r\nimport {\r\n  MtxSplitArea,\r\n  MtxSplitPoint,\r\n  MtxSplitSnapshot,\r\n  MtxSplitAreaSnapshot,\r\n  MtxSplitOutputData,\r\n  MtxSplitOutputAreaSizes,\r\n} from './interface';\r\nimport { MtxSplitPaneDirective } from './split-pane.directive';\r\nimport {\r\n  getInputPositiveNumber,\r\n  getInputBoolean,\r\n  isUserSizesValid,\r\n  getAreaMinSize,\r\n  getAreaMaxSize,\r\n  getPointFromEvent,\r\n  getElementPixelSize,\r\n  getGutterSideAbsorptionCapacity,\r\n  updateAreaSize,\r\n} from './utils';\r\n\r\n/**\r\n * mtx-split\r\n *\r\n *\r\n *  PERCENT MODE ([unit]=\"'percent'\")\r\n *  ___________________________________________________________________________________________\r\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\r\n * |-------------------------------------------------------------------------------------------|\r\n * |       20                 30                 20                 15                 15      | <-- [size]=\"x\"\r\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\r\n * |calc(20% - 8px)    calc(30% - 12px)   calc(20% - 8px)    calc(15% - 6px)    calc(15% - 6px)| <-- CSS flex-basis property (with flex-grow&shrink at 0)\r\n * |     152px              228px              152px              114px              114px     | <-- el.getBoundingClientRect().width\r\n * |___________________________________________________________________________________________|\r\n *                                                                                 800px         <-- el.getBoundingClientRect().width\r\n *  flex-basis = calc( { area.size }% - { area.size/100 * nbGutter*gutterSize }px );\r\n *\r\n *\r\n *  PIXEL MODE ([unit]=\"'pixel'\")\r\n *  ___________________________________________________________________________________________\r\n * |       A       [g1]       B       [g2]       C       [g3]       D       [g4]       E       |\r\n * |-------------------------------------------------------------------------------------------|\r\n * |      100                250                 *                 150                100      | <-- [size]=\"y\"\r\n * |               10px               10px               10px               10px               | <-- [gutterSize]=\"10\"\r\n * |   0 0 100px          0 0 250px           1 1 auto          0 0 150px          0 0 100px   | <-- CSS flex property (flex-grow/flex-shrink/flex-basis)\r\n * |     100px              250px              200px              150px              100px     | <-- el.getBoundingClientRect().width\r\n * |___________________________________________________________________________________________|\r\n *                                                                                 800px         <-- el.getBoundingClientRect().width\r\n *\r\n */\r\n\r\n@Component({\r\n  selector: 'mtx-split',\r\n  exportAs: 'mtxSplit',\r\n  host: {\r\n    class: 'mtx-split',\r\n  },\r\n  encapsulation: ViewEncapsulation.None,\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  styleUrls: [`./split.component.scss`],\r\n  templateUrl: './split.component.html',\r\n})\r\nexport class MtxSplitComponent implements AfterViewInit, OnDestroy {\r\n  private _direction: 'horizontal' | 'vertical' = 'horizontal';\r\n\r\n  @Input() set direction(v: 'horizontal' | 'vertical') {\r\n    this._direction = v === 'vertical' ? 'vertical' : 'horizontal';\r\n\r\n    this.renderer.addClass(this.elRef.nativeElement, `mtx-split-${this._direction}`);\r\n    this.renderer.removeClass(\r\n      this.elRef.nativeElement,\r\n      `mtx-split-${this._direction === 'vertical' ? 'horizontal' : 'vertical'}`\r\n    );\r\n\r\n    this.build(false, false);\r\n  }\r\n\r\n  get direction(): 'horizontal' | 'vertical' {\r\n    return this._direction;\r\n  }\r\n\r\n  ////\r\n\r\n  private _unit: 'percent' | 'pixel' = 'percent';\r\n\r\n  @Input() set unit(v: 'percent' | 'pixel') {\r\n    this._unit = v === 'pixel' ? 'pixel' : 'percent';\r\n\r\n    this.renderer.addClass(this.elRef.nativeElement, `mtx-split-${this._unit}`);\r\n    this.renderer.removeClass(\r\n      this.elRef.nativeElement,\r\n      `mtx-split-${this._unit === 'pixel' ? 'percent' : 'pixel'}`\r\n    );\r\n\r\n    this.build(false, true);\r\n  }\r\n\r\n  get unit(): 'percent' | 'pixel' {\r\n    return this._unit;\r\n  }\r\n\r\n  ////\r\n\r\n  private _gutterSize = 1;\r\n\r\n  @Input() set gutterSize(v: number) {\r\n    this._gutterSize = getInputPositiveNumber(v, 11);\r\n\r\n    this.build(false, false);\r\n  }\r\n\r\n  get gutterSize(): number {\r\n    return this._gutterSize;\r\n  }\r\n\r\n  ////\r\n\r\n  private _gutterStep = 1;\r\n\r\n  @Input() set gutterStep(v: number) {\r\n    this._gutterStep = getInputPositiveNumber(v, 1);\r\n  }\r\n\r\n  get gutterStep(): number {\r\n    return this._gutterStep;\r\n  }\r\n\r\n  ////\r\n\r\n  private _restrictMove = false;\r\n\r\n  @Input() set restrictMove(v: boolean) {\r\n    this._restrictMove = getInputBoolean(v);\r\n  }\r\n\r\n  get restrictMove(): boolean {\r\n    return this._restrictMove;\r\n  }\r\n\r\n  ////\r\n\r\n  private _useTransition = false;\r\n\r\n  @Input() set useTransition(v: boolean) {\r\n    this._useTransition = getInputBoolean(v);\r\n\r\n    if (this._useTransition) {\r\n      this.renderer.addClass(this.elRef.nativeElement, 'mtx-split-transition');\r\n    } else {\r\n      this.renderer.removeClass(this.elRef.nativeElement, 'mtx-split-transition');\r\n    }\r\n  }\r\n\r\n  get useTransition(): boolean {\r\n    return this._useTransition;\r\n  }\r\n\r\n  ////\r\n\r\n  private _disabled = false;\r\n\r\n  @Input() set disabled(v: boolean) {\r\n    this._disabled = getInputBoolean(v);\r\n\r\n    if (this._disabled) {\r\n      this.renderer.addClass(this.elRef.nativeElement, 'mtx-split-disabled');\r\n    } else {\r\n      this.renderer.removeClass(this.elRef.nativeElement, 'mtx-split-disabled');\r\n    }\r\n  }\r\n\r\n  get disabled(): boolean {\r\n    return this._disabled;\r\n  }\r\n\r\n  ////\r\n\r\n  private _dir: 'ltr' | 'rtl' = 'ltr';\r\n\r\n  @Input() set dir(v: 'ltr' | 'rtl') {\r\n    this._dir = v === 'rtl' ? 'rtl' : 'ltr';\r\n\r\n    this.renderer.setAttribute(this.elRef.nativeElement, 'dir', this._dir);\r\n  }\r\n\r\n  get dir(): 'ltr' | 'rtl' {\r\n    return this._dir;\r\n  }\r\n\r\n  ////\r\n\r\n  private _gutterDblClickDuration = 0;\r\n\r\n  @Input() set gutterDblClickDuration(v: number) {\r\n    this._gutterDblClickDuration = getInputPositiveNumber(v, 0);\r\n  }\r\n\r\n  get gutterDblClickDuration(): number {\r\n    return this._gutterDblClickDuration;\r\n  }\r\n\r\n  ////\r\n\r\n  @Output() dragStart = new EventEmitter<MtxSplitOutputData>(false);\r\n  @Output() dragEnd = new EventEmitter<MtxSplitOutputData>(false);\r\n  @Output() gutterClick = new EventEmitter<MtxSplitOutputData>(false);\r\n  @Output() gutterDblClick = new EventEmitter<MtxSplitOutputData>(false);\r\n\r\n  private transitionEndSubscriber: Subscriber<MtxSplitOutputAreaSizes>;\r\n  @Output() get transitionEnd(): Observable<MtxSplitOutputAreaSizes> {\r\n    return new Observable(subscriber => (this.transitionEndSubscriber = subscriber)).pipe(\r\n      debounceTime<any>(20)\r\n    );\r\n  }\r\n\r\n  private dragProgressSubject: Subject<MtxSplitOutputData> = new Subject();\r\n  dragProgress$: Observable<MtxSplitOutputData> = this.dragProgressSubject.asObservable();\r\n\r\n  ////\r\n\r\n  private isDragging = false;\r\n  private dragListeners: Array<() => void> = [];\r\n  private snapshot: MtxSplitSnapshot | null = null;\r\n  private startPoint: MtxSplitPoint | null = null;\r\n  private endPoint: MtxSplitPoint | null = null;\r\n\r\n  public readonly displayedAreas: Array<MtxSplitArea> = [];\r\n  private readonly hidedAreas: Array<MtxSplitArea> = [];\r\n\r\n  @ViewChildren('gutterEls') private gutterEls: QueryList<ElementRef>;\r\n\r\n  constructor(\r\n    private ngZone: NgZone,\r\n    private elRef: ElementRef,\r\n    private cdRef: ChangeDetectorRef,\r\n    private renderer: Renderer2\r\n  ) {\r\n    // To force adding default class, could be override by user @Input() or not\r\n    this.direction = this._direction;\r\n  }\r\n\r\n  public ngAfterViewInit() {\r\n    this.ngZone.runOutsideAngular(() => {\r\n      // To avoid transition at first rendering\r\n      setTimeout(() => this.renderer.addClass(this.elRef.nativeElement, 'mtx-split-init'));\r\n    });\r\n  }\r\n\r\n  private getNbGutters(): number {\r\n    return this.displayedAreas.length === 0 ? 0 : this.displayedAreas.length - 1;\r\n  }\r\n\r\n  public addArea(component: MtxSplitPaneDirective): void {\r\n    const newArea: MtxSplitArea = {\r\n      component,\r\n      order: 0,\r\n      size: 0,\r\n      minSize: null,\r\n      maxSize: null,\r\n    };\r\n\r\n    if (component.visible === true) {\r\n      this.displayedAreas.push(newArea);\r\n\r\n      this.build(true, true);\r\n    } else {\r\n      this.hidedAreas.push(newArea);\r\n    }\r\n  }\r\n\r\n  public removeArea(component: MtxSplitPaneDirective): void {\r\n    if (this.displayedAreas.some(a => a.component === component)) {\r\n      const area = this.displayedAreas.find(a => a.component === component) as MtxSplitArea;\r\n      this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\r\n\r\n      this.build(true, true);\r\n    } else if (this.hidedAreas.some(a => a.component === component)) {\r\n      const area = this.hidedAreas.find(a => a.component === component) as MtxSplitArea;\r\n      this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\r\n    }\r\n  }\r\n\r\n  public updateArea(\r\n    component: MtxSplitPaneDirective,\r\n    resetOrders: boolean,\r\n    resetSizes: boolean\r\n  ): void {\r\n    if (component.visible === true) {\r\n      this.build(resetOrders, resetSizes);\r\n    }\r\n  }\r\n\r\n  public showArea(component: MtxSplitPaneDirective): void {\r\n    const area = this.hidedAreas.find(a => a.component === component);\r\n    if (area === undefined) {\r\n      return;\r\n    }\r\n\r\n    const areas = this.hidedAreas.splice(this.hidedAreas.indexOf(area), 1);\r\n    this.displayedAreas.push(...areas);\r\n\r\n    this.build(true, true);\r\n  }\r\n\r\n  public hideArea(comp: MtxSplitPaneDirective): void {\r\n    const area = this.displayedAreas.find(a => a.component === comp);\r\n    if (area === undefined) {\r\n      return;\r\n    }\r\n\r\n    const areas = this.displayedAreas.splice(this.displayedAreas.indexOf(area), 1);\r\n    areas.forEach(_area => {\r\n      _area.order = 0;\r\n      _area.size = 0;\r\n    });\r\n    this.hidedAreas.push(...areas);\r\n\r\n    this.build(true, true);\r\n  }\r\n\r\n  public getVisibleAreaSizes(): MtxSplitOutputAreaSizes {\r\n    return this.displayedAreas.map(a => (a.size === null ? '*' : a.size));\r\n  }\r\n\r\n  public setVisibleAreaSizes(sizes: MtxSplitOutputAreaSizes): boolean {\r\n    if (sizes.length !== this.displayedAreas.length) {\r\n      return false;\r\n    }\r\n\r\n    const formatedSizes = sizes.map(s => getInputPositiveNumber(s, null)) as number[];\r\n    const isValid = isUserSizesValid(this.unit, formatedSizes);\r\n\r\n    if (isValid === false) {\r\n      return false;\r\n    }\r\n\r\n    // @ts-ignore\r\n    this.displayedAreas.forEach((area, i) => (area.component._size = formatedSizes[i]));\r\n\r\n    this.build(false, true);\r\n    return true;\r\n  }\r\n\r\n  private build(resetOrders: boolean, resetSizes: boolean): void {\r\n    this.stopDragging();\r\n\r\n    // ¤ AREAS ORDER\r\n\r\n    if (resetOrders === true) {\r\n      // If user provided 'order' for each area, use it to sort them.\r\n      if (this.displayedAreas.every(a => a.component.order !== null)) {\r\n        this.displayedAreas.sort(\r\n          (a, b) => ((a.component.order as number) - (b.component.order as number)) as number\r\n        );\r\n      }\r\n\r\n      // Then set real order with multiples of 2, numbers between will be used by gutters.\r\n      this.displayedAreas.forEach((area, i) => {\r\n        area.order = i * 2;\r\n        area.component.setStyleOrder(area.order);\r\n      });\r\n    }\r\n\r\n    // ¤ AREAS SIZE\r\n\r\n    if (resetSizes === true) {\r\n      const useUserSizes = isUserSizesValid(\r\n        this.unit,\r\n        this.displayedAreas.map(a => a.component.size) as number[]\r\n      );\r\n\r\n      switch (this.unit) {\r\n        case 'percent': {\r\n          const defaultSize = 100 / this.displayedAreas.length;\r\n\r\n          this.displayedAreas.forEach(area => {\r\n            area.size = useUserSizes ? (area.component.size as number) : defaultSize;\r\n            area.minSize = getAreaMinSize(area);\r\n            area.maxSize = getAreaMaxSize(area);\r\n          });\r\n          break;\r\n        }\r\n        case 'pixel': {\r\n          if (useUserSizes) {\r\n            this.displayedAreas.forEach(area => {\r\n              area.size = area.component.size;\r\n              area.minSize = getAreaMinSize(area);\r\n              area.maxSize = getAreaMaxSize(area);\r\n            });\r\n          } else {\r\n            const wildcardSizeAreas = this.displayedAreas.filter(a => a.component.size === null);\r\n\r\n            // No wildcard area > Need to select one arbitrarily > first\r\n            if (wildcardSizeAreas.length === 0 && this.displayedAreas.length > 0) {\r\n              this.displayedAreas.forEach((area, i) => {\r\n                area.size = i === 0 ? null : area.component.size;\r\n                area.minSize = i === 0 ? null : getAreaMinSize(area);\r\n                area.maxSize = i === 0 ? null : getAreaMaxSize(area);\r\n              });\r\n            }\r\n            // More than one wildcard area > Need to keep only one arbitrarly > first\r\n            // tslint:disable-next-line: one-line\r\n            else if (wildcardSizeAreas.length > 1) {\r\n              let alreadyGotOne = false;\r\n              this.displayedAreas.forEach(area => {\r\n                if (area.component.size === null) {\r\n                  if (alreadyGotOne === false) {\r\n                    area.size = null;\r\n                    area.minSize = null;\r\n                    area.maxSize = null;\r\n                    alreadyGotOne = true;\r\n                  } else {\r\n                    area.size = 100;\r\n                    area.minSize = null;\r\n                    area.maxSize = null;\r\n                  }\r\n                } else {\r\n                  area.size = area.component.size;\r\n                  area.minSize = getAreaMinSize(area);\r\n                  area.maxSize = getAreaMaxSize(area);\r\n                }\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.refreshStyleSizes();\r\n    this.cdRef.markForCheck();\r\n  }\r\n\r\n  private refreshStyleSizes(): void {\r\n    ///////////////////////////////////////////\r\n    // PERCENT MODE\r\n    if (this.unit === 'percent') {\r\n      // Only one area > flex-basis 100%\r\n      if (this.displayedAreas.length === 1) {\r\n        this.displayedAreas[0].component.setStyleFlex(0, 0, `100%`, false, false);\r\n      }\r\n      // Multiple areas > use each percent basis\r\n      // tslint:disable-next-line: one-line\r\n      else {\r\n        const sumGutterSize = this.getNbGutters() * this.gutterSize;\r\n\r\n        this.displayedAreas.forEach(area => {\r\n          area.component.setStyleFlex(\r\n            0,\r\n            0,\r\n            `calc( ${area.size}% - ${((area.size as number) / 100) * sumGutterSize}px )`,\r\n            area.minSize !== null && area.minSize === area.size ? true : false,\r\n            area.maxSize !== null && area.maxSize === area.size ? true : false\r\n          );\r\n        });\r\n      }\r\n    }\r\n    ///////////////////////////////////////////\r\n    // PIXEL MODE\r\n    // tslint:disable-next-line: one-line\r\n    else if (this.unit === 'pixel') {\r\n      this.displayedAreas.forEach(area => {\r\n        // Area with wildcard size\r\n        if (area.size === null) {\r\n          if (this.displayedAreas.length === 1) {\r\n            area.component.setStyleFlex(1, 1, `100%`, false, false);\r\n          } else {\r\n            area.component.setStyleFlex(1, 1, `auto`, false, false);\r\n          }\r\n        }\r\n        // Area with pixel size\r\n        // tslint:disable-next-line: one-line\r\n        else {\r\n          // Only one area > flex-basis 100%\r\n          if (this.displayedAreas.length === 1) {\r\n            area.component.setStyleFlex(0, 0, `100%`, false, false);\r\n          }\r\n          // Multiple areas > use each pixel basis\r\n          // tslint:disable-next-line: one-line\r\n          else {\r\n            area.component.setStyleFlex(\r\n              0,\r\n              0,\r\n              `${area.size}px`,\r\n              area.minSize !== null && area.minSize === area.size ? true : false,\r\n              area.maxSize !== null && area.maxSize === area.size ? true : false\r\n            );\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  _clickTimeout: number | null = null;\r\n\r\n  public clickGutter(event: MouseEvent | TouchEvent, gutterNum: number): void {\r\n    const tempPoint = getPointFromEvent(event) as MtxSplitPoint;\r\n\r\n    // Be sure mouseup/touchend happened at same point as mousedown/touchstart to trigger click/dblclick\r\n    if (this.startPoint && this.startPoint.x === tempPoint.x && this.startPoint.y === tempPoint.y) {\r\n      // If timeout in progress and new click > clearTimeout & dblClickEvent\r\n      if (this._clickTimeout !== null) {\r\n        window.clearTimeout(this._clickTimeout);\r\n        this._clickTimeout = null;\r\n        this.notify('dblclick', gutterNum);\r\n        this.stopDragging();\r\n      }\r\n      // Else start timeout to call clickEvent at end\r\n      // tslint:disable-next-line: one-line\r\n      else {\r\n        this._clickTimeout = window.setTimeout(() => {\r\n          this._clickTimeout = null;\r\n          this.notify('click', gutterNum);\r\n          this.stopDragging();\r\n        }, this.gutterDblClickDuration);\r\n      }\r\n    }\r\n  }\r\n\r\n  public startDragging(\r\n    event: MouseEvent | TouchEvent,\r\n    gutterOrder: number,\r\n    gutterNum: number\r\n  ): void {\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n\r\n    this.startPoint = getPointFromEvent(event);\r\n    if (this.startPoint === null || this.disabled === true) {\r\n      return;\r\n    }\r\n\r\n    this.snapshot = {\r\n      gutterNum,\r\n      lastSteppedOffset: 0,\r\n      allAreasSizePixel:\r\n        getElementPixelSize(this.elRef, this.direction) - this.getNbGutters() * this.gutterSize,\r\n      allInvolvedAreasSizePercent: 100,\r\n      areasBeforeGutter: [],\r\n      areasAfterGutter: [],\r\n    };\r\n\r\n    this.displayedAreas.forEach(area => {\r\n      const areaSnapshot: MtxSplitAreaSnapshot = {\r\n        area,\r\n        sizePixelAtStart: getElementPixelSize(area.component.elRef, this.direction),\r\n        sizePercentAtStart: (this.unit === 'percent' ? area.size : -1) as number, // If pixel mode, anyway, will not be used.\r\n      };\r\n\r\n      if (area.order < gutterOrder) {\r\n        if (this.restrictMove === true) {\r\n          (this.snapshot as MtxSplitSnapshot).areasBeforeGutter = [areaSnapshot];\r\n        } else {\r\n          (this.snapshot as MtxSplitSnapshot).areasBeforeGutter.unshift(areaSnapshot);\r\n        }\r\n      } else if (area.order > gutterOrder) {\r\n        if (this.restrictMove === true) {\r\n          if ((this.snapshot as MtxSplitSnapshot).areasAfterGutter.length === 0) {\r\n            (this.snapshot as MtxSplitSnapshot).areasAfterGutter = [areaSnapshot];\r\n          }\r\n        } else {\r\n          (this.snapshot as MtxSplitSnapshot).areasAfterGutter.push(areaSnapshot);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.snapshot.allInvolvedAreasSizePercent = [\r\n      ...this.snapshot.areasBeforeGutter,\r\n      ...this.snapshot.areasAfterGutter,\r\n    ].reduce((t, a) => t + a.sizePercentAtStart, 0);\r\n\r\n    if (\r\n      this.snapshot.areasBeforeGutter.length === 0 ||\r\n      this.snapshot.areasAfterGutter.length === 0\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    this.dragListeners.push(\r\n      this.renderer.listen('document', 'mouseup', this.stopDragging.bind(this))\r\n    );\r\n    this.dragListeners.push(\r\n      this.renderer.listen('document', 'touchend', this.stopDragging.bind(this))\r\n    );\r\n    this.dragListeners.push(\r\n      this.renderer.listen('document', 'touchcancel', this.stopDragging.bind(this))\r\n    );\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this.dragListeners.push(\r\n        this.renderer.listen('document', 'mousemove', this.dragEvent.bind(this))\r\n      );\r\n      this.dragListeners.push(\r\n        this.renderer.listen('document', 'touchmove', this.dragEvent.bind(this))\r\n      );\r\n    });\r\n\r\n    this.displayedAreas.forEach(area => area.component.lockEvents());\r\n\r\n    this.isDragging = true;\r\n    this.renderer.addClass(this.elRef.nativeElement, 'mtx-dragging');\r\n    this.renderer.addClass(\r\n      this.gutterEls.toArray()[this.snapshot.gutterNum - 1].nativeElement,\r\n      'mtx-dragged'\r\n    );\r\n\r\n    this.notify('start', this.snapshot.gutterNum);\r\n  }\r\n\r\n  private dragEvent(event: MouseEvent | TouchEvent): void {\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n\r\n    if (this._clickTimeout !== null) {\r\n      window.clearTimeout(this._clickTimeout);\r\n      this._clickTimeout = null;\r\n    }\r\n\r\n    if (this.isDragging === false) {\r\n      return;\r\n    }\r\n\r\n    this.endPoint = getPointFromEvent(event);\r\n    if (this.endPoint === null) {\r\n      return;\r\n    }\r\n\r\n    // Calculate steppedOffset\r\n\r\n    let offset =\r\n      this.direction === 'horizontal'\r\n        ? (this.startPoint as MtxSplitPoint).x - this.endPoint.x\r\n        : (this.startPoint as MtxSplitPoint).y - this.endPoint.y;\r\n    if (this.dir === 'rtl') {\r\n      offset = -offset;\r\n    }\r\n    const steppedOffset = Math.round(offset / this.gutterStep) * this.gutterStep;\r\n\r\n    if (steppedOffset === (this.snapshot as MtxSplitSnapshot).lastSteppedOffset) {\r\n      return;\r\n    }\r\n\r\n    (this.snapshot as MtxSplitSnapshot).lastSteppedOffset = steppedOffset;\r\n\r\n    // Need to know if each gutter side areas could reacts to steppedOffset\r\n\r\n    let areasBefore = getGutterSideAbsorptionCapacity(\r\n      this.unit,\r\n      (this.snapshot as MtxSplitSnapshot).areasBeforeGutter,\r\n      -steppedOffset,\r\n      (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n    );\r\n    let areasAfter = getGutterSideAbsorptionCapacity(\r\n      this.unit,\r\n      (this.snapshot as MtxSplitSnapshot).areasAfterGutter,\r\n      steppedOffset,\r\n      (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n    );\r\n\r\n    // Each gutter side areas can't absorb all offset\r\n    if (areasBefore.remain !== 0 && areasAfter.remain !== 0) {\r\n      if (Math.abs(areasBefore.remain) === Math.abs(areasAfter.remain)) {\r\n      } else if (Math.abs(areasBefore.remain) > Math.abs(areasAfter.remain)) {\r\n        areasAfter = getGutterSideAbsorptionCapacity(\r\n          this.unit,\r\n          (this.snapshot as MtxSplitSnapshot).areasAfterGutter,\r\n          steppedOffset + areasBefore.remain,\r\n          (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n        );\r\n      } else {\r\n        areasBefore = getGutterSideAbsorptionCapacity(\r\n          this.unit,\r\n          (this.snapshot as MtxSplitSnapshot).areasBeforeGutter,\r\n          -(steppedOffset - areasAfter.remain),\r\n          (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n        );\r\n      }\r\n    }\r\n    // Areas before gutter can't absorbs all offset > need to recalculate sizes for areas after gutter.\r\n    // tslint:disable-next-line: one-line\r\n    else if (areasBefore.remain !== 0) {\r\n      areasAfter = getGutterSideAbsorptionCapacity(\r\n        this.unit,\r\n        (this.snapshot as MtxSplitSnapshot).areasAfterGutter,\r\n        steppedOffset + areasBefore.remain,\r\n        (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n      );\r\n    }\r\n    // Areas after gutter can't absorbs all offset > need to recalculate sizes for areas before gutter.\r\n    // tslint:disable-next-line: one-line\r\n    else if (areasAfter.remain !== 0) {\r\n      areasBefore = getGutterSideAbsorptionCapacity(\r\n        this.unit,\r\n        (this.snapshot as MtxSplitSnapshot).areasBeforeGutter,\r\n        -(steppedOffset - areasAfter.remain),\r\n        (this.snapshot as MtxSplitSnapshot).allAreasSizePixel\r\n      );\r\n    }\r\n\r\n    if (this.unit === 'percent') {\r\n      // Hack because of browser messing up with sizes using calc(X% - Ypx) -> el.getBoundingClientRect()\r\n      // If not there, playing with gutters makes total going down to 99.99875% then 99.99286%, 99.98986%,..\r\n      const all = [...areasBefore.list, ...areasAfter.list];\r\n      const areaToReset = all.find(\r\n        a =>\r\n          a.percentAfterAbsorption !== 0 &&\r\n          a.percentAfterAbsorption !== a.areaSnapshot.area.minSize &&\r\n          a.percentAfterAbsorption !== a.areaSnapshot.area.maxSize\r\n      );\r\n\r\n      if (areaToReset) {\r\n        areaToReset.percentAfterAbsorption =\r\n          (this.snapshot as MtxSplitSnapshot).allInvolvedAreasSizePercent -\r\n          all\r\n            .filter(a => a !== areaToReset)\r\n            .reduce((total, a) => total + a.percentAfterAbsorption, 0);\r\n      }\r\n    }\r\n\r\n    // Now we know areas could absorb steppedOffset, time to really update sizes\r\n\r\n    areasBefore.list.forEach(item => updateAreaSize(this.unit, item));\r\n    areasAfter.list.forEach(item => updateAreaSize(this.unit, item));\r\n\r\n    this.refreshStyleSizes();\r\n    this.notify('progress', (this.snapshot as MtxSplitSnapshot).gutterNum);\r\n  }\r\n\r\n  private stopDragging(event?: Event): void {\r\n    if (event) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n    }\r\n\r\n    if (this.isDragging === false) {\r\n      return;\r\n    }\r\n\r\n    this.displayedAreas.forEach(area => area.component.unlockEvents());\r\n\r\n    while (this.dragListeners.length > 0) {\r\n      const fct = this.dragListeners.pop();\r\n      if (fct) {\r\n        fct();\r\n      }\r\n    }\r\n\r\n    // Warning: Have to be before \"notify('end')\"\r\n    // because \"notify('end')\"\" can be linked to \"[size]='x'\" > \"build()\" > \"stopDragging()\"\r\n    this.isDragging = false;\r\n\r\n    // If moved from starting point, notify end\r\n    if (\r\n      this.endPoint &&\r\n      ((this.startPoint as MtxSplitPoint).x !== this.endPoint.x ||\r\n        (this.startPoint as MtxSplitPoint).y !== this.endPoint.y)\r\n    ) {\r\n      this.notify('end', (this.snapshot as MtxSplitSnapshot).gutterNum);\r\n    }\r\n\r\n    this.renderer.removeClass(this.elRef.nativeElement, 'mtx-dragging');\r\n    this.renderer.removeClass(\r\n      this.gutterEls.toArray()[(this.snapshot as MtxSplitSnapshot).gutterNum - 1].nativeElement,\r\n      'mtx-dragged'\r\n    );\r\n    this.snapshot = null;\r\n\r\n    // Needed to let (click)=\"clickGutter(...)\" event run and verify if mouse moved or not\r\n    this.ngZone.runOutsideAngular(() => {\r\n      setTimeout(() => {\r\n        this.startPoint = null;\r\n        this.endPoint = null;\r\n      });\r\n    });\r\n  }\r\n\r\n  public notify(\r\n    type: 'start' | 'progress' | 'end' | 'click' | 'dblclick' | 'transitionEnd',\r\n    gutterNum: number\r\n  ): void {\r\n    const sizes = this.getVisibleAreaSizes();\r\n\r\n    if (type === 'start') {\r\n      this.dragStart.emit({ gutterNum, sizes });\r\n    } else if (type === 'end') {\r\n      this.dragEnd.emit({ gutterNum, sizes });\r\n    } else if (type === 'click') {\r\n      this.gutterClick.emit({ gutterNum, sizes });\r\n    } else if (type === 'dblclick') {\r\n      this.gutterDblClick.emit({ gutterNum, sizes });\r\n    } else if (type === 'transitionEnd') {\r\n      if (this.transitionEndSubscriber) {\r\n        this.ngZone.run(() => this.transitionEndSubscriber.next(sizes));\r\n      }\r\n    } else if (type === 'progress') {\r\n      // Stay outside zone to allow users do what they want about change detection mechanism.\r\n      this.dragProgressSubject.next({ gutterNum, sizes });\r\n    }\r\n  }\r\n\r\n  public ngOnDestroy(): void {\r\n    this.stopDragging();\r\n  }\r\n}\r\n","import { Directive, Input, ElementRef, Renderer2, OnInit, OnDestroy, NgZone } from '@angular/core';\r\n\r\nimport { MtxSplitComponent } from './split.component';\r\nimport { getInputPositiveNumber, getInputBoolean } from './utils';\r\n\r\n@Directive({\r\n  selector: 'mtx-split-pane, [mtx-split-pane]',\r\n  exportAs: 'mtxSplitPane',\r\n})\r\nexport class MtxSplitPaneDirective implements OnInit, OnDestroy {\r\n  private _order: number | null = null;\r\n\r\n  @Input() set order(v: number | null) {\r\n    this._order = getInputPositiveNumber(v, null);\r\n\r\n    this.split.updateArea(this, true, false);\r\n  }\r\n\r\n  get order(): number | null {\r\n    return this._order;\r\n  }\r\n\r\n  ////\r\n\r\n  private _size: number | null = null;\r\n\r\n  @Input() set size(v: number | null) {\r\n    this._size = getInputPositiveNumber(v, null);\r\n\r\n    this.split.updateArea(this, false, true);\r\n  }\r\n\r\n  get size(): number | null {\r\n    return this._size;\r\n  }\r\n\r\n  ////\r\n\r\n  private _minSize: number | null = null;\r\n\r\n  @Input() set minSize(v: number | null) {\r\n    this._minSize = getInputPositiveNumber(v, null);\r\n\r\n    this.split.updateArea(this, false, true);\r\n  }\r\n\r\n  get minSize(): number | null {\r\n    return this._minSize;\r\n  }\r\n\r\n  ////\r\n\r\n  private _maxSize: number | null = null;\r\n\r\n  @Input() set maxSize(v: number | null) {\r\n    this._maxSize = getInputPositiveNumber(v, null);\r\n\r\n    this.split.updateArea(this, false, true);\r\n  }\r\n\r\n  get maxSize(): number | null {\r\n    return this._maxSize;\r\n  }\r\n\r\n  ////\r\n\r\n  private _lockSize = false;\r\n\r\n  @Input() set lockSize(v: boolean) {\r\n    this._lockSize = getInputBoolean(v);\r\n\r\n    this.split.updateArea(this, false, true);\r\n  }\r\n\r\n  get lockSize(): boolean {\r\n    return this._lockSize;\r\n  }\r\n\r\n  ////\r\n\r\n  private _visible = true;\r\n\r\n  @Input() set visible(v: boolean) {\r\n    this._visible = getInputBoolean(v);\r\n\r\n    if (this._visible) {\r\n      this.split.showArea(this);\r\n      this.renderer.removeClass(this.elRef.nativeElement, 'mtx-split-pane-hidden');\r\n    } else {\r\n      this.split.hideArea(this);\r\n      this.renderer.addClass(this.elRef.nativeElement, 'mtx-split-pane-hidden');\r\n    }\r\n  }\r\n\r\n  get visible(): boolean {\r\n    return this._visible;\r\n  }\r\n\r\n  ////\r\n\r\n  private transitionListener: () => void;\r\n  private readonly lockListeners: Array<() => void> = [];\r\n\r\n  constructor(\r\n    private ngZone: NgZone,\r\n    public elRef: ElementRef,\r\n    private renderer: Renderer2,\r\n    private split: MtxSplitComponent\r\n  ) {\r\n    this.renderer.addClass(this.elRef.nativeElement, 'mtx-split-pane');\r\n  }\r\n\r\n  public ngOnInit(): void {\r\n    this.split.addArea(this);\r\n\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this.transitionListener = this.renderer.listen(\r\n        this.elRef.nativeElement,\r\n        'transitionend',\r\n        (event: TransitionEvent) => {\r\n          // Limit only flex-basis transition to trigger the event\r\n          if (event.propertyName === 'flex-basis') {\r\n            this.split.notify('transitionEnd', -1);\r\n          }\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  public setStyleOrder(value: number): void {\r\n    this.renderer.setStyle(this.elRef.nativeElement, 'order', value);\r\n  }\r\n\r\n  public setStyleFlex(\r\n    grow: number,\r\n    shrink: number,\r\n    basis: string,\r\n    isMin: boolean,\r\n    isMax: boolean\r\n  ): void {\r\n    // Need 3 separated properties to work on IE11 (https://github.com/angular/flex-layout/issues/323)\r\n    this.renderer.setStyle(this.elRef.nativeElement, 'flex-grow', grow);\r\n    this.renderer.setStyle(this.elRef.nativeElement, 'flex-shrink', shrink);\r\n    this.renderer.setStyle(this.elRef.nativeElement, 'flex-basis', basis);\r\n\r\n    if (isMin === true) {\r\n      this.renderer.addClass(this.elRef.nativeElement, 'mtx-min');\r\n    } else {\r\n      this.renderer.removeClass(this.elRef.nativeElement, 'mtx-min');\r\n    }\r\n\r\n    if (isMax === true) {\r\n      this.renderer.addClass(this.elRef.nativeElement, 'mtx-max');\r\n    } else {\r\n      this.renderer.removeClass(this.elRef.nativeElement, 'mtx-max');\r\n    }\r\n  }\r\n\r\n  public lockEvents(): void {\r\n    this.ngZone.runOutsideAngular(() => {\r\n      this.lockListeners.push(\r\n        this.renderer.listen(this.elRef.nativeElement, 'selectstart', (e: Event) => false)\r\n      );\r\n      this.lockListeners.push(\r\n        this.renderer.listen(this.elRef.nativeElement, 'dragstart', (e: Event) => false)\r\n      );\r\n    });\r\n  }\r\n\r\n  public unlockEvents(): void {\r\n    while (this.lockListeners.length > 0) {\r\n      const fct = this.lockListeners.pop();\r\n      if (fct) {\r\n        fct();\r\n      }\r\n    }\r\n  }\r\n\r\n  public ngOnDestroy(): void {\r\n    this.unlockEvents();\r\n\r\n    if (this.transitionListener) {\r\n      this.transitionListener();\r\n    }\r\n\r\n    this.split.removeArea(this);\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\n\r\nimport { MtxSplitComponent } from './split.component';\r\nimport { MtxSplitPaneDirective } from './split-pane.directive';\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  declarations: [MtxSplitComponent, MtxSplitPaneDirective],\r\n  exports: [MtxSplitComponent, MtxSplitPaneDirective],\r\n})\r\nexport class MtxSplitModule {}\r\n"]}